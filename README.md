# gosshttpresearch

Цель исследования – глубже погрузиться в механизм веб-протоколов. В Node.js есть модуль net и модуль http. В первом имеется объект Сокет, через который полнодуплексно реализуется всё взаимодействие (это поток для чтения и записи), а во втором реализуется более высокий уровень абстракции: вводятся Запрос и Ответ. Это тоже потоки.

На уровне net то, что мы отсылаем методом POST представляет собой единый «кусок» данных. С более высокой точки зрения там находятся заголовк и тело, между которыми два символа перевода строки. Модуль http оперирует ими по отдельности: заголовки доступны серверу через req.headers и req.url, а тело – через поток.

Метод http.request() возвращает объект класса ClientRequest. Он абстрагирует находящийся в ходе выполнения запрос. С помощью метода setHeader(name, value), мы можем изменять его заголовки. С помощью метода end() мы можем отправить запрос.

В файле sender.js мы как раз посылаем такой запрос. Ответ сервера тоже рассматривается по отдельности: мы можем посмотреть заголовки ответа в событии request.on('response') и мы можем прочитать тело сообщения через поток.

Файлы sender-net-get-with-body.js и server-net.js позволяют создать примитивную реализацию взаимодействия веб-клиента и веб-сервера на низком уровне сокетов. В частности, server-net может вместо HTTP /1.1 отправить XXXX /6.66 и клиент это благополучно получит и покажет, никаких ошибок не возникнет. А вот если запустить server-net в компании с sender.js, то тут плохой ответ сервера вызовет ошибку request.on('error').

Например, если в одном окне терминала выполнить ./server-net.js XXXX

а в другом ./sender.js

то получим срабатывание on('error') с сообщением Parse Error: Expected HTTP/
